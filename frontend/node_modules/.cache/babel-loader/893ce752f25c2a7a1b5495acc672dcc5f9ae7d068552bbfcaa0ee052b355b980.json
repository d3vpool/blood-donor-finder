{"ast":null,"code":"/**\r\n * src/firebaseMessaging.js\r\n *\r\n * Uses the default firebase app exported from ./firebase if caller doesn't pass an app.\r\n * Exports:\r\n *  - initMessaging(appOrNull, swPath)\r\n *  - setupAutoRegistration({ app, uid, swPath })\r\n *  - registerTokenForUser(token, uid, app)\r\n *  - removeTokenForUser(uid, app)\r\n *  - listenForegroundMessages(callback, app)\r\n */import firebaseAppDefault from'./firebase';// your local firebase initializer (default export)\nimport{getMessaging,getToken,onMessage}from'firebase/messaging';import{getFirestore,doc,updateDoc,arrayUnion,arrayRemove,getDoc,setDoc}from'firebase/firestore';/* Helper: resolve a firebase app instance. Use provided app, otherwise fall back to default export. */function resolveApp(maybeApp){if(maybeApp)return maybeApp;if(firebaseAppDefault)return firebaseAppDefault;throw new Error('Firebase app instance required. Initialize firebase app and pass it or ensure default export exists in ./firebase.');}/**\r\n * Initialize messaging and register service worker.\r\n * @param {FirebaseApp|null} appOrNull\r\n * @param {string} swPath\r\n * @returns {Promise<{messaging: Messaging, serviceWorkerRegistration: ServiceWorkerRegistration|null}>}\r\n */export async function initMessaging(){let appOrNull=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;let swPath=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'/firebase-messaging-sw.js';const app=resolveApp(appOrNull);let registration=null;if('serviceWorker'in navigator){try{registration=await navigator.serviceWorker.register(swPath);}catch(err){console.warn('Service worker registration failed:',err);}}else{console.warn('Service workers are not supported in this browser.');}const messaging=getMessaging(app);return{messaging,serviceWorkerRegistration:registration};}/**\r\n * Request permission, get token and register it for the uid in Firestore.\r\n * @param {{app?: FirebaseApp, uid: string, swPath?: string}} param0\r\n */export async function setupAutoRegistration(){let{app:maybeApp=null,uid,swPath}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const app=resolveApp(maybeApp);if(!uid)throw new Error('setupAutoRegistration: uid is required');const permission=await Notification.requestPermission();if(permission!=='granted'){console.warn('Notification permission not granted:',permission);return null;}const{messaging,serviceWorkerRegistration}=await initMessaging(app,swPath);const vapidKey=process.env.REACT_APP_FIREBASE_VAPID_KEY||process.env.REACT_APP_VAPID_KEY||null;try{let currentToken;if(serviceWorkerRegistration){if(vapidKey){currentToken=await getToken(messaging,{vapidKey,serviceWorkerRegistration});}else{currentToken=await getToken(messaging,{serviceWorkerRegistration});}}else{if(vapidKey){currentToken=await getToken(messaging,{vapidKey});}else{currentToken=await getToken(messaging);}}if(currentToken){await registerTokenForUser(currentToken,uid,app);return currentToken;}else{console.warn('No registration token available.');return null;}}catch(err){console.error('An error occurred while retrieving token. ',err);throw err;}}/**\r\n * Store token into users/{uid}.fcmTokens array in Firestore.\r\n */export async function registerTokenForUser(token,uid){let app=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!token)throw new Error('registerTokenForUser: token required');if(!uid)throw new Error('registerTokenForUser: uid required');const appToUse=resolveApp(app);const db=getFirestore(appToUse);const userRef=doc(db,'users',uid);try{const snapshot=await getDoc(userRef);if(!snapshot.exists()){await setDoc(userRef,{fcmTokens:[token]},{merge:true});}else{await updateDoc(userRef,{fcmTokens:arrayUnion(token)});}}catch(err){console.error('registerTokenForUser failed:',err);throw err;}}/**\r\n * Remove current device token from users/{uid}.fcmTokens array.\r\n */export async function removeTokenForUser(uid){let app=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;if(!uid)throw new Error('removeTokenForUser: uid required');const appToUse=resolveApp(app);const db=getFirestore(appToUse);const userRef=doc(db,'users',uid);try{const messaging=getMessaging(appToUse);const vapidKey=process.env.REACT_APP_FIREBASE_VAPID_KEY||process.env.REACT_APP_VAPID_KEY||null;let token=null;try{if(vapidKey)token=await getToken(messaging,{vapidKey});else token=await getToken(messaging);}catch(tErr){console.warn('Could not fetch current token (getToken):',tErr);return false;}if(!token)return true;await updateDoc(userRef,{fcmTokens:arrayRemove(token)});return true;}catch(err){console.error('removeTokenForUser failed:',err);return false;}}/**\r\n * Listen to foreground messages. Optionally pass an app to ensure correct messaging instance.\r\n * @param {(payload:Object)=>void} callback\r\n * @param {FirebaseApp|null} app\r\n */export function listenForegroundMessages(callback){let app=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;if(typeof callback!=='function')throw new Error('listenForegroundMessages: callback function required');const appToUse=resolveApp(app);const messaging=getMessaging(appToUse);const unsub=onMessage(messaging,payload=>{try{callback(payload);}catch(err){console.error('Error in foreground message callback:',err);}});return typeof unsub==='function'?unsub:()=>{};}export default{initMessaging,setupAutoRegistration,registerTokenForUser,removeTokenForUser,listenForegroundMessages};","map":{"version":3,"names":["firebaseAppDefault","getMessaging","getToken","onMessage","getFirestore","doc","updateDoc","arrayUnion","arrayRemove","getDoc","setDoc","resolveApp","maybeApp","Error","initMessaging","appOrNull","arguments","length","undefined","swPath","app","registration","navigator","serviceWorker","register","err","console","warn","messaging","serviceWorkerRegistration","setupAutoRegistration","uid","permission","Notification","requestPermission","vapidKey","process","env","REACT_APP_FIREBASE_VAPID_KEY","REACT_APP_VAPID_KEY","currentToken","registerTokenForUser","error","token","appToUse","db","userRef","snapshot","exists","fcmTokens","merge","removeTokenForUser","tErr","listenForegroundMessages","callback","unsub","payload"],"sources":["C:/Users/rajya/Desktop/Coding/WebDev/Programs/mini_project_LifeLink/blood-donor-finder/frontend/src/firebaseMessaging.js"],"sourcesContent":["/**\r\n * src/firebaseMessaging.js\r\n *\r\n * Uses the default firebase app exported from ./firebase if caller doesn't pass an app.\r\n * Exports:\r\n *  - initMessaging(appOrNull, swPath)\r\n *  - setupAutoRegistration({ app, uid, swPath })\r\n *  - registerTokenForUser(token, uid, app)\r\n *  - removeTokenForUser(uid, app)\r\n *  - listenForegroundMessages(callback, app)\r\n */\r\n\r\nimport firebaseAppDefault from './firebase'; // your local firebase initializer (default export)\r\nimport { getMessaging, getToken, onMessage } from 'firebase/messaging';\r\nimport {\r\n  getFirestore,\r\n  doc,\r\n  updateDoc,\r\n  arrayUnion,\r\n  arrayRemove,\r\n  getDoc,\r\n  setDoc,\r\n} from 'firebase/firestore';\r\n\r\n/* Helper: resolve a firebase app instance. Use provided app, otherwise fall back to default export. */\r\nfunction resolveApp(maybeApp) {\r\n  if (maybeApp) return maybeApp;\r\n  if (firebaseAppDefault) return firebaseAppDefault;\r\n  throw new Error('Firebase app instance required. Initialize firebase app and pass it or ensure default export exists in ./firebase.');\r\n}\r\n\r\n/**\r\n * Initialize messaging and register service worker.\r\n * @param {FirebaseApp|null} appOrNull\r\n * @param {string} swPath\r\n * @returns {Promise<{messaging: Messaging, serviceWorkerRegistration: ServiceWorkerRegistration|null}>}\r\n */\r\nexport async function initMessaging(appOrNull = null, swPath = '/firebase-messaging-sw.js') {\r\n  const app = resolveApp(appOrNull);\r\n\r\n  let registration = null;\r\n  if ('serviceWorker' in navigator) {\r\n    try {\r\n      registration = await navigator.serviceWorker.register(swPath);\r\n    } catch (err) {\r\n      console.warn('Service worker registration failed:', err);\r\n    }\r\n  } else {\r\n    console.warn('Service workers are not supported in this browser.');\r\n  }\r\n\r\n  const messaging = getMessaging(app);\r\n  return { messaging, serviceWorkerRegistration: registration };\r\n}\r\n\r\n/**\r\n * Request permission, get token and register it for the uid in Firestore.\r\n * @param {{app?: FirebaseApp, uid: string, swPath?: string}} param0\r\n */\r\nexport async function setupAutoRegistration({ app: maybeApp = null, uid, swPath } = {}) {\r\n  const app = resolveApp(maybeApp);\r\n  if (!uid) throw new Error('setupAutoRegistration: uid is required');\r\n\r\n  const permission = await Notification.requestPermission();\r\n  if (permission !== 'granted') {\r\n    console.warn('Notification permission not granted:', permission);\r\n    return null;\r\n  }\r\n\r\n  const { messaging, serviceWorkerRegistration } = await initMessaging(app, swPath);\r\n  const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\r\n\r\n  try {\r\n    let currentToken;\r\n    if (serviceWorkerRegistration) {\r\n      if (vapidKey) {\r\n        currentToken = await getToken(messaging, { vapidKey, serviceWorkerRegistration });\r\n      } else {\r\n        currentToken = await getToken(messaging, { serviceWorkerRegistration });\r\n      }\r\n    } else {\r\n      if (vapidKey) {\r\n        currentToken = await getToken(messaging, { vapidKey });\r\n      } else {\r\n        currentToken = await getToken(messaging);\r\n      }\r\n    }\r\n\r\n    if (currentToken) {\r\n      await registerTokenForUser(currentToken, uid, app);\r\n      return currentToken;\r\n    } else {\r\n      console.warn('No registration token available.');\r\n      return null;\r\n    }\r\n  } catch (err) {\r\n    console.error('An error occurred while retrieving token. ', err);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * Store token into users/{uid}.fcmTokens array in Firestore.\r\n */\r\nexport async function registerTokenForUser(token, uid, app = null) {\r\n  if (!token) throw new Error('registerTokenForUser: token required');\r\n  if (!uid) throw new Error('registerTokenForUser: uid required');\r\n\r\n  const appToUse = resolveApp(app);\r\n  const db = getFirestore(appToUse);\r\n  const userRef = doc(db, 'users', uid);\r\n\r\n  try {\r\n    const snapshot = await getDoc(userRef);\r\n    if (!snapshot.exists()) {\r\n      await setDoc(userRef, { fcmTokens: [token] }, { merge: true });\r\n    } else {\r\n      await updateDoc(userRef, { fcmTokens: arrayUnion(token) });\r\n    }\r\n  } catch (err) {\r\n    console.error('registerTokenForUser failed:', err);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * Remove current device token from users/{uid}.fcmTokens array.\r\n */\r\nexport async function removeTokenForUser(uid, app = null) {\r\n  if (!uid) throw new Error('removeTokenForUser: uid required');\r\n\r\n  const appToUse = resolveApp(app);\r\n  const db = getFirestore(appToUse);\r\n  const userRef = doc(db, 'users', uid);\r\n\r\n  try {\r\n    const messaging = getMessaging(appToUse);\r\n    const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\r\n\r\n    let token = null;\r\n    try {\r\n      if (vapidKey) token = await getToken(messaging, { vapidKey });\r\n      else token = await getToken(messaging);\r\n    } catch (tErr) {\r\n      console.warn('Could not fetch current token (getToken):', tErr);\r\n      return false;\r\n    }\r\n\r\n    if (!token) return true;\r\n\r\n    await updateDoc(userRef, { fcmTokens: arrayRemove(token) });\r\n    return true;\r\n  } catch (err) {\r\n    console.error('removeTokenForUser failed:', err);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Listen to foreground messages. Optionally pass an app to ensure correct messaging instance.\r\n * @param {(payload:Object)=>void} callback\r\n * @param {FirebaseApp|null} app\r\n */\r\nexport function listenForegroundMessages(callback, app = null) {\r\n  if (typeof callback !== 'function') throw new Error('listenForegroundMessages: callback function required');\r\n  const appToUse = resolveApp(app);\r\n  const messaging = getMessaging(appToUse);\r\n  const unsub = onMessage(messaging, (payload) => {\r\n    try {\r\n      callback(payload);\r\n    } catch (err) {\r\n      console.error('Error in foreground message callback:', err);\r\n    }\r\n  });\r\n  return typeof unsub === 'function' ? unsub : () => {};\r\n}\r\n\r\nexport default {\r\n  initMessaging,\r\n  setupAutoRegistration,\r\n  registerTokenForUser,\r\n  removeTokenForUser,\r\n  listenForegroundMessages,\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}