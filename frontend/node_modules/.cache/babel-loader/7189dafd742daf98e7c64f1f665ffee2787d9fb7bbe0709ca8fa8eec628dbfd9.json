{"ast":null,"code":"// --- PATCH START ---\n// Replace the top imports and the initMessaging & setupAutoRegistration functions\n// in your firebaseMessaging.js with the code below.\n\nimport { getApp, getApps } from './firebase';\nimport { getMessaging, getToken, onMessage } from 'firebase/messaging';\nimport { getFirestore, doc, updateDoc, arrayUnion, arrayRemove, getDoc, setDoc } from 'firebase/firestore';\n\n/**\r\n * Helper: resolve a firebase app instance.\r\n * If the caller passed an app, use it. Otherwise use the default app if initialized.\r\n * Throws only if no app is available.\r\n */\nfunction resolveApp(maybeApp) {\n  if (maybeApp) return maybeApp;\n  // if any apps were initialized, return the first (default) one\n  if (getApps && getApps().length > 0) return getApp();\n  throw new Error('Firebase app instance required. Initialize firebase app and pass it or ensure default app exists.');\n}\n\n/**\r\n * Initialize messaging and register service worker.\r\n * @param {FirebaseApp} appOrNull - optional initialized firebase app (from firebase/app). If not provided, default app is used.\r\n * @param {string} [swPath='/firebase-messaging-sw.js'] - service worker file path in public/\r\n * @returns {Promise<{messaging: Messaging, serviceWorkerRegistration: ServiceWorkerRegistration|null}>}\r\n */\nexport async function initMessaging(appOrNull, swPath = '/firebase-messaging-sw.js') {\n  const app = resolveApp(appOrNull);\n\n  // Ensure service worker registration\n  let registration = null;\n  if ('serviceWorker' in navigator) {\n    try {\n      registration = await navigator.serviceWorker.register(swPath);\n    } catch (err) {\n      console.warn('Service worker registration failed:', err);\n    }\n  } else {\n    console.warn('Service workers are not supported in this browser.');\n  }\n  const messaging = getMessaging(app);\n  return {\n    messaging,\n    serviceWorkerRegistration: registration\n  };\n}\n\n/**\r\n * Request Notification permission, get FCM token, and register token for the user (Firestore).\r\n * Accepts either an explicit app or will use default firebase app.\r\n *\r\n * @param {Object} opts\r\n * @param {FirebaseApp} [opts.app] - optional initialized firebase app\r\n * @param {string} opts.uid - current user's uid\r\n * @param {string} [opts.swPath] - optional service worker path (defaults to /firebase-messaging-sw.js)\r\n * @returns {Promise<string|null>} - the token if registered, otherwise null\r\n */\nexport async function setupAutoRegistration({\n  app: maybeApp,\n  uid,\n  swPath\n} = {}) {\n  const app = resolveApp(maybeApp);\n  if (!uid) throw new Error('setupAutoRegistration: uid is required');\n\n  // Request browser permission\n  const permission = await Notification.requestPermission();\n  if (permission !== 'granted') {\n    console.warn('Notification permission not granted:', permission);\n    return null;\n  }\n  const {\n    messaging,\n    serviceWorkerRegistration\n  } = await initMessaging(app, swPath);\n  const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\n  try {\n    let currentToken;\n    if (serviceWorkerRegistration) {\n      if (vapidKey) {\n        currentToken = await getToken(messaging, {\n          vapidKey,\n          serviceWorkerRegistration\n        });\n      } else {\n        currentToken = await getToken(messaging, {\n          serviceWorkerRegistration\n        });\n      }\n    } else {\n      if (vapidKey) {\n        currentToken = await getToken(messaging, {\n          vapidKey\n        });\n      } else {\n        currentToken = await getToken(messaging);\n      }\n    }\n    if (currentToken) {\n      await registerTokenForUser(currentToken, uid, app);\n      return currentToken;\n    } else {\n      console.warn('No registration token available. Request permission to generate one.');\n      return null;\n    }\n  } catch (err) {\n    console.error('An error occurred while retrieving token. ', err);\n    throw err;\n  }\n}\n// --- PATCH END ---\n\n/**\r\n * Store the given token for the user in Firestore.\r\n * Schema used: collection `users`, doc `uid`, array field `fcmTokens`.\r\n * @param {string} token\r\n * @param {string} uid\r\n * @param {FirebaseApp} [app]\r\n */\nexport async function registerTokenForUser(token, uid, app = null) {\n  if (!token) throw new Error('registerTokenForUser: token required');\n  if (!uid) throw new Error('registerTokenForUser: uid required');\n  const db = getFirestore(app);\n  const userRef = doc(db, 'users', uid);\n  try {\n    const snapshot = await getDoc(userRef);\n    if (!snapshot.exists()) {\n      await setDoc(userRef, {\n        fcmTokens: [token]\n      }, {\n        merge: true\n      });\n    } else {\n      await updateDoc(userRef, {\n        fcmTokens: arrayUnion(token)\n      });\n    }\n  } catch (err) {\n    console.error('registerTokenForUser failed:', err);\n    throw err;\n  }\n}\n\n/**\r\n * Remove the current device token from the user's stored tokens.\r\n * Attempts to get client token then removes it from Firestore array.\r\n * @param {string} uid\r\n * @param {FirebaseApp} [app]\r\n * @returns {Promise<boolean>}\r\n */\nexport async function removeTokenForUser(uid, app = null) {\n  if (!uid) throw new Error('removeTokenForUser: uid required');\n  const db = getFirestore(app);\n  const userRef = doc(db, 'users', uid);\n  try {\n    const messaging = getMessaging();\n    const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\n    let token = null;\n    try {\n      if (vapidKey) token = await getToken(messaging, {\n        vapidKey\n      });else token = await getToken(messaging);\n    } catch (tErr) {\n      console.warn('Could not fetch current token (getToken):', tErr);\n      return false;\n    }\n    if (!token) return true;\n    await updateDoc(userRef, {\n      fcmTokens: arrayRemove(token)\n    });\n    return true;\n  } catch (err) {\n    console.error('removeTokenForUser failed:', err);\n    return false;\n  }\n}\n\n/**\r\n * Listen to foreground messages (when web page is open)\r\n * @param {(payload: Object) => void} callback\r\n * @returns {() => void} unsubscribe function\r\n */\nexport function listenForegroundMessages(callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('listenForegroundMessages: callback function required');\n  }\n  const messaging = getMessaging();\n  const unsub = onMessage(messaging, payload => {\n    try {\n      callback(payload);\n    } catch (err) {\n      console.error('Error in foreground message callback:', err);\n    }\n  });\n  return typeof unsub === 'function' ? unsub : () => {};\n}\nexport default {\n  initMessaging,\n  setupAutoRegistration,\n  registerTokenForUser,\n  removeTokenForUser,\n  listenForegroundMessages\n};","map":{"version":3,"names":["getApp","getApps","getMessaging","getToken","onMessage","getFirestore","doc","updateDoc","arrayUnion","arrayRemove","getDoc","setDoc","resolveApp","maybeApp","length","Error","initMessaging","appOrNull","swPath","app","registration","navigator","serviceWorker","register","err","console","warn","messaging","serviceWorkerRegistration","setupAutoRegistration","uid","permission","Notification","requestPermission","vapidKey","process","env","REACT_APP_FIREBASE_VAPID_KEY","REACT_APP_VAPID_KEY","currentToken","registerTokenForUser","error","token","db","userRef","snapshot","exists","fcmTokens","merge","removeTokenForUser","tErr","listenForegroundMessages","callback","unsub","payload"],"sources":["C:/Users/rajya/Desktop/Coding/WebDev/Programs/mini_project_LifeLink/blood-donor-finder/frontend/src/firebaseMessaging.js"],"sourcesContent":["// --- PATCH START ---\r\n// Replace the top imports and the initMessaging & setupAutoRegistration functions\r\n// in your firebaseMessaging.js with the code below.\r\n\r\nimport { getApp, getApps } from './firebase';\r\nimport { getMessaging, getToken, onMessage } from 'firebase/messaging';\r\nimport {\r\n  getFirestore,\r\n  doc,\r\n  updateDoc,\r\n  arrayUnion,\r\n  arrayRemove,\r\n  getDoc,\r\n  setDoc,\r\n} from 'firebase/firestore';\r\n\r\n/**\r\n * Helper: resolve a firebase app instance.\r\n * If the caller passed an app, use it. Otherwise use the default app if initialized.\r\n * Throws only if no app is available.\r\n */\r\nfunction resolveApp(maybeApp) {\r\n  if (maybeApp) return maybeApp;\r\n  // if any apps were initialized, return the first (default) one\r\n  if (getApps && getApps().length > 0) return getApp();\r\n  throw new Error('Firebase app instance required. Initialize firebase app and pass it or ensure default app exists.');\r\n}\r\n\r\n/**\r\n * Initialize messaging and register service worker.\r\n * @param {FirebaseApp} appOrNull - optional initialized firebase app (from firebase/app). If not provided, default app is used.\r\n * @param {string} [swPath='/firebase-messaging-sw.js'] - service worker file path in public/\r\n * @returns {Promise<{messaging: Messaging, serviceWorkerRegistration: ServiceWorkerRegistration|null}>}\r\n */\r\nexport async function initMessaging(appOrNull, swPath = '/firebase-messaging-sw.js') {\r\n  const app = resolveApp(appOrNull);\r\n\r\n  // Ensure service worker registration\r\n  let registration = null;\r\n  if ('serviceWorker' in navigator) {\r\n    try {\r\n      registration = await navigator.serviceWorker.register(swPath);\r\n    } catch (err) {\r\n      console.warn('Service worker registration failed:', err);\r\n    }\r\n  } else {\r\n    console.warn('Service workers are not supported in this browser.');\r\n  }\r\n\r\n  const messaging = getMessaging(app);\r\n  return { messaging, serviceWorkerRegistration: registration };\r\n}\r\n\r\n/**\r\n * Request Notification permission, get FCM token, and register token for the user (Firestore).\r\n * Accepts either an explicit app or will use default firebase app.\r\n *\r\n * @param {Object} opts\r\n * @param {FirebaseApp} [opts.app] - optional initialized firebase app\r\n * @param {string} opts.uid - current user's uid\r\n * @param {string} [opts.swPath] - optional service worker path (defaults to /firebase-messaging-sw.js)\r\n * @returns {Promise<string|null>} - the token if registered, otherwise null\r\n */\r\nexport async function setupAutoRegistration({ app: maybeApp, uid, swPath } = {}) {\r\n  const app = resolveApp(maybeApp);\r\n  if (!uid) throw new Error('setupAutoRegistration: uid is required');\r\n\r\n  // Request browser permission\r\n  const permission = await Notification.requestPermission();\r\n  if (permission !== 'granted') {\r\n    console.warn('Notification permission not granted:', permission);\r\n    return null;\r\n  }\r\n\r\n  const { messaging, serviceWorkerRegistration } = await initMessaging(app, swPath);\r\n  const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\r\n\r\n  try {\r\n    let currentToken;\r\n    if (serviceWorkerRegistration) {\r\n      if (vapidKey) {\r\n        currentToken = await getToken(messaging, {\r\n          vapidKey,\r\n          serviceWorkerRegistration,\r\n        });\r\n      } else {\r\n        currentToken = await getToken(messaging, { serviceWorkerRegistration });\r\n      }\r\n    } else {\r\n      if (vapidKey) {\r\n        currentToken = await getToken(messaging, { vapidKey });\r\n      } else {\r\n        currentToken = await getToken(messaging);\r\n      }\r\n    }\r\n\r\n    if (currentToken) {\r\n      await registerTokenForUser(currentToken, uid, app);\r\n      return currentToken;\r\n    } else {\r\n      console.warn('No registration token available. Request permission to generate one.');\r\n      return null;\r\n    }\r\n  } catch (err) {\r\n    console.error('An error occurred while retrieving token. ', err);\r\n    throw err;\r\n  }\r\n}\r\n// --- PATCH END ---\r\n\r\n/**\r\n * Store the given token for the user in Firestore.\r\n * Schema used: collection `users`, doc `uid`, array field `fcmTokens`.\r\n * @param {string} token\r\n * @param {string} uid\r\n * @param {FirebaseApp} [app]\r\n */\r\nexport async function registerTokenForUser(token, uid, app = null) {\r\n  if (!token) throw new Error('registerTokenForUser: token required');\r\n  if (!uid) throw new Error('registerTokenForUser: uid required');\r\n\r\n  const db = getFirestore(app);\r\n  const userRef = doc(db, 'users', uid);\r\n\r\n  try {\r\n    const snapshot = await getDoc(userRef);\r\n    if (!snapshot.exists()) {\r\n      await setDoc(userRef, { fcmTokens: [token] }, { merge: true });\r\n    } else {\r\n      await updateDoc(userRef, { fcmTokens: arrayUnion(token) });\r\n    }\r\n  } catch (err) {\r\n    console.error('registerTokenForUser failed:', err);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * Remove the current device token from the user's stored tokens.\r\n * Attempts to get client token then removes it from Firestore array.\r\n * @param {string} uid\r\n * @param {FirebaseApp} [app]\r\n * @returns {Promise<boolean>}\r\n */\r\nexport async function removeTokenForUser(uid, app = null) {\r\n  if (!uid) throw new Error('removeTokenForUser: uid required');\r\n\r\n  const db = getFirestore(app);\r\n  const userRef = doc(db, 'users', uid);\r\n\r\n  try {\r\n    const messaging = getMessaging();\r\n    const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\r\n\r\n    let token = null;\r\n    try {\r\n      if (vapidKey) token = await getToken(messaging, { vapidKey });\r\n      else token = await getToken(messaging);\r\n    } catch (tErr) {\r\n      console.warn('Could not fetch current token (getToken):', tErr);\r\n      return false;\r\n    }\r\n\r\n    if (!token) return true;\r\n\r\n    await updateDoc(userRef, { fcmTokens: arrayRemove(token) });\r\n    return true;\r\n  } catch (err) {\r\n    console.error('removeTokenForUser failed:', err);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Listen to foreground messages (when web page is open)\r\n * @param {(payload: Object) => void} callback\r\n * @returns {() => void} unsubscribe function\r\n */\r\nexport function listenForegroundMessages(callback) {\r\n  if (typeof callback !== 'function') {\r\n    throw new Error('listenForegroundMessages: callback function required');\r\n  }\r\n  const messaging = getMessaging();\r\n  const unsub = onMessage(messaging, (payload) => {\r\n    try {\r\n      callback(payload);\r\n    } catch (err) {\r\n      console.error('Error in foreground message callback:', err);\r\n    }\r\n  });\r\n\r\n  return typeof unsub === 'function' ? unsub : () => {};\r\n}\r\n\r\nexport default {\r\n  initMessaging,\r\n  setupAutoRegistration,\r\n  registerTokenForUser,\r\n  removeTokenForUser,\r\n  listenForegroundMessages,\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}