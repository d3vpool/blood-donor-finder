{"ast":null,"code":"/**\r\n * firebaseMessaging.js\r\n *\r\n * Corrected, self-contained helper for Firebase Cloud Messaging (FCM) on the client.\r\n * - Modular Firebase v9+ API (v12 compatible)\r\n * - Exports:\r\n *    initMessaging(app)                     -> initializes messaging and registers service worker (returns messaging + registration)\r\n *    setupAutoRegistration({ app, uid })    -> requests permission, gets token, stores it for the uid\r\n *    registerTokenForUser(token, uid)       -> stores token into Firestore under `users/{uid}.fcmTokens`\r\n *    removeTokenForUser(uid)                -> removes current device token from user's doc\r\n *    listenForegroundMessages(callback)     -> subscribe to onMessage (foreground)\r\n */\n\nimport { getMessaging, getToken, onMessage } from 'firebase/messaging';\nimport { getFirestore, doc, updateDoc, arrayUnion, arrayRemove, getDoc, setDoc } from 'firebase/firestore';\n\n/**\r\n * Initialize messaging and register service worker.\r\n * @param {FirebaseApp} app - initialized firebase app (from firebase/app)\r\n * @param {string} [swPath='/firebase-messaging-sw.js'] - service worker file path in public/\r\n * @returns {Promise<{messaging: import('firebase/messaging').Messaging, serviceWorkerRegistration: ServiceWorkerRegistration|null}>}\r\n */\nexport async function initMessaging(app, swPath = '/firebase-messaging-sw.js') {\n  if (!app) throw new Error('initMessaging: firebase app instance required');\n  let registration = null;\n  if ('serviceWorker' in navigator) {\n    try {\n      registration = await navigator.serviceWorker.register(swPath);\n    } catch (err) {\n      console.warn('Service worker registration failed:', err);\n    }\n  } else {\n    console.warn('Service workers are not supported in this browser.');\n  }\n  const messaging = getMessaging(app);\n  return {\n    messaging,\n    serviceWorkerRegistration: registration\n  };\n}\n\n/**\r\n * Request Notification permission, get FCM token, and register token for the user (Firestore).\r\n * @param {Object} opts\r\n * @param {FirebaseApp} opts.app - initialized firebase app\r\n * @param {string} opts.uid - current user's uid\r\n * @param {string} [opts.swPath] - optional service worker path\r\n * @returns {Promise<string|null>}\r\n */\nexport async function setupAutoRegistration({\n  app,\n  uid,\n  swPath\n}) {\n  if (!app) throw new Error('setupAutoRegistration: firebase app is required');\n  if (!uid) throw new Error('setupAutoRegistration: uid is required');\n  const permission = await Notification.requestPermission();\n  if (permission !== 'granted') {\n    console.warn('Notification permission not granted:', permission);\n    return null;\n  }\n  const {\n    messaging,\n    serviceWorkerRegistration\n  } = await initMessaging(app, swPath);\n  const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\n  try {\n    let currentToken;\n    if (serviceWorkerRegistration) {\n      if (vapidKey) {\n        currentToken = await getToken(messaging, {\n          vapidKey,\n          serviceWorkerRegistration\n        });\n      } else {\n        currentToken = await getToken(messaging, {\n          serviceWorkerRegistration\n        });\n      }\n    } else {\n      if (vapidKey) {\n        currentToken = await getToken(messaging, {\n          vapidKey\n        });\n      } else {\n        currentToken = await getToken(messaging);\n      }\n    }\n    if (currentToken) {\n      await registerTokenForUser(currentToken, uid, app);\n      return currentToken;\n    } else {\n      console.warn('No registration token available. Request permission to generate one.');\n      return null;\n    }\n  } catch (err) {\n    console.error('An error occurred while retrieving token. ', err);\n    throw err;\n  }\n}\n\n/**\r\n * Store the given token for the user in Firestore.\r\n * Schema used: collection `users`, doc `uid`, array field `fcmTokens`.\r\n * @param {string} token\r\n * @param {string} uid\r\n * @param {FirebaseApp} [app]\r\n */\nexport async function registerTokenForUser(token, uid, app = null) {\n  if (!token) throw new Error('registerTokenForUser: token required');\n  if (!uid) throw new Error('registerTokenForUser: uid required');\n  const db = getFirestore(app);\n  const userRef = doc(db, 'users', uid);\n  try {\n    const snapshot = await getDoc(userRef);\n    if (!snapshot.exists()) {\n      await setDoc(userRef, {\n        fcmTokens: [token]\n      }, {\n        merge: true\n      });\n    } else {\n      await updateDoc(userRef, {\n        fcmTokens: arrayUnion(token)\n      });\n    }\n  } catch (err) {\n    console.error('registerTokenForUser failed:', err);\n    throw err;\n  }\n}\n\n/**\r\n * Remove the current device token from the user's stored tokens.\r\n * Attempts to get client token then removes it from Firestore array.\r\n * @param {string} uid\r\n * @param {FirebaseApp} [app]\r\n * @returns {Promise<boolean>}\r\n */\nexport async function removeTokenForUser(uid, app = null) {\n  if (!uid) throw new Error('removeTokenForUser: uid required');\n  const db = getFirestore(app);\n  const userRef = doc(db, 'users', uid);\n  try {\n    const messaging = getMessaging();\n    const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\n    let token = null;\n    try {\n      if (vapidKey) token = await getToken(messaging, {\n        vapidKey\n      });else token = await getToken(messaging);\n    } catch (tErr) {\n      console.warn('Could not fetch current token (getToken):', tErr);\n      return false;\n    }\n    if (!token) return true;\n    await updateDoc(userRef, {\n      fcmTokens: arrayRemove(token)\n    });\n    return true;\n  } catch (err) {\n    console.error('removeTokenForUser failed:', err);\n    return false;\n  }\n}\n\n/**\r\n * Listen to foreground messages (when web page is open)\r\n * @param {(payload: Object) => void} callback\r\n * @returns {() => void} unsubscribe function\r\n */\nexport function listenForegroundMessages(callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('listenForegroundMessages: callback function required');\n  }\n  const messaging = getMessaging();\n  const unsub = onMessage(messaging, payload => {\n    try {\n      callback(payload);\n    } catch (err) {\n      console.error('Error in foreground message callback:', err);\n    }\n  });\n  return typeof unsub === 'function' ? unsub : () => {};\n}\nexport default {\n  initMessaging,\n  setupAutoRegistration,\n  registerTokenForUser,\n  removeTokenForUser,\n  listenForegroundMessages\n};","map":{"version":3,"names":["getMessaging","getToken","onMessage","getFirestore","doc","updateDoc","arrayUnion","arrayRemove","getDoc","setDoc","initMessaging","app","swPath","Error","registration","navigator","serviceWorker","register","err","console","warn","messaging","serviceWorkerRegistration","setupAutoRegistration","uid","permission","Notification","requestPermission","vapidKey","process","env","REACT_APP_FIREBASE_VAPID_KEY","REACT_APP_VAPID_KEY","currentToken","registerTokenForUser","error","token","db","userRef","snapshot","exists","fcmTokens","merge","removeTokenForUser","tErr","listenForegroundMessages","callback","unsub","payload"],"sources":["C:/Users/rajya/Desktop/Coding/WebDev/Programs/mini_project_LifeLink/blood-donor-finder/frontend/src/firebaseMessaging.js"],"sourcesContent":["/**\r\n * firebaseMessaging.js\r\n *\r\n * Corrected, self-contained helper for Firebase Cloud Messaging (FCM) on the client.\r\n * - Modular Firebase v9+ API (v12 compatible)\r\n * - Exports:\r\n *    initMessaging(app)                     -> initializes messaging and registers service worker (returns messaging + registration)\r\n *    setupAutoRegistration({ app, uid })    -> requests permission, gets token, stores it for the uid\r\n *    registerTokenForUser(token, uid)       -> stores token into Firestore under `users/{uid}.fcmTokens`\r\n *    removeTokenForUser(uid)                -> removes current device token from user's doc\r\n *    listenForegroundMessages(callback)     -> subscribe to onMessage (foreground)\r\n */\r\n\r\nimport { getMessaging, getToken, onMessage } from 'firebase/messaging';\r\nimport {\r\n  getFirestore,\r\n  doc,\r\n  updateDoc,\r\n  arrayUnion,\r\n  arrayRemove,\r\n  getDoc,\r\n  setDoc,\r\n} from 'firebase/firestore';\r\n\r\n/**\r\n * Initialize messaging and register service worker.\r\n * @param {FirebaseApp} app - initialized firebase app (from firebase/app)\r\n * @param {string} [swPath='/firebase-messaging-sw.js'] - service worker file path in public/\r\n * @returns {Promise<{messaging: import('firebase/messaging').Messaging, serviceWorkerRegistration: ServiceWorkerRegistration|null}>}\r\n */\r\nexport async function initMessaging(app, swPath = '/firebase-messaging-sw.js') {\r\n  if (!app) throw new Error('initMessaging: firebase app instance required');\r\n\r\n  let registration = null;\r\n  if ('serviceWorker' in navigator) {\r\n    try {\r\n      registration = await navigator.serviceWorker.register(swPath);\r\n    } catch (err) {\r\n      console.warn('Service worker registration failed:', err);\r\n    }\r\n  } else {\r\n    console.warn('Service workers are not supported in this browser.');\r\n  }\r\n\r\n  const messaging = getMessaging(app);\r\n  return { messaging, serviceWorkerRegistration: registration };\r\n}\r\n\r\n/**\r\n * Request Notification permission, get FCM token, and register token for the user (Firestore).\r\n * @param {Object} opts\r\n * @param {FirebaseApp} opts.app - initialized firebase app\r\n * @param {string} opts.uid - current user's uid\r\n * @param {string} [opts.swPath] - optional service worker path\r\n * @returns {Promise<string|null>}\r\n */\r\nexport async function setupAutoRegistration({ app, uid, swPath }) {\r\n  if (!app) throw new Error('setupAutoRegistration: firebase app is required');\r\n  if (!uid) throw new Error('setupAutoRegistration: uid is required');\r\n\r\n  const permission = await Notification.requestPermission();\r\n  if (permission !== 'granted') {\r\n    console.warn('Notification permission not granted:', permission);\r\n    return null;\r\n  }\r\n\r\n  const { messaging, serviceWorkerRegistration } = await initMessaging(app, swPath);\r\n\r\n  const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\r\n\r\n  try {\r\n    let currentToken;\r\n    if (serviceWorkerRegistration) {\r\n      if (vapidKey) {\r\n        currentToken = await getToken(messaging, {\r\n          vapidKey,\r\n          serviceWorkerRegistration,\r\n        });\r\n      } else {\r\n        currentToken = await getToken(messaging, { serviceWorkerRegistration });\r\n      }\r\n    } else {\r\n      if (vapidKey) {\r\n        currentToken = await getToken(messaging, { vapidKey });\r\n      } else {\r\n        currentToken = await getToken(messaging);\r\n      }\r\n    }\r\n\r\n    if (currentToken) {\r\n      await registerTokenForUser(currentToken, uid, app);\r\n      return currentToken;\r\n    } else {\r\n      console.warn('No registration token available. Request permission to generate one.');\r\n      return null;\r\n    }\r\n  } catch (err) {\r\n    console.error('An error occurred while retrieving token. ', err);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * Store the given token for the user in Firestore.\r\n * Schema used: collection `users`, doc `uid`, array field `fcmTokens`.\r\n * @param {string} token\r\n * @param {string} uid\r\n * @param {FirebaseApp} [app]\r\n */\r\nexport async function registerTokenForUser(token, uid, app = null) {\r\n  if (!token) throw new Error('registerTokenForUser: token required');\r\n  if (!uid) throw new Error('registerTokenForUser: uid required');\r\n\r\n  const db = getFirestore(app);\r\n  const userRef = doc(db, 'users', uid);\r\n\r\n  try {\r\n    const snapshot = await getDoc(userRef);\r\n    if (!snapshot.exists()) {\r\n      await setDoc(userRef, { fcmTokens: [token] }, { merge: true });\r\n    } else {\r\n      await updateDoc(userRef, { fcmTokens: arrayUnion(token) });\r\n    }\r\n  } catch (err) {\r\n    console.error('registerTokenForUser failed:', err);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * Remove the current device token from the user's stored tokens.\r\n * Attempts to get client token then removes it from Firestore array.\r\n * @param {string} uid\r\n * @param {FirebaseApp} [app]\r\n * @returns {Promise<boolean>}\r\n */\r\nexport async function removeTokenForUser(uid, app = null) {\r\n  if (!uid) throw new Error('removeTokenForUser: uid required');\r\n\r\n  const db = getFirestore(app);\r\n  const userRef = doc(db, 'users', uid);\r\n\r\n  try {\r\n    const messaging = getMessaging();\r\n    const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\r\n\r\n    let token = null;\r\n    try {\r\n      if (vapidKey) token = await getToken(messaging, { vapidKey });\r\n      else token = await getToken(messaging);\r\n    } catch (tErr) {\r\n      console.warn('Could not fetch current token (getToken):', tErr);\r\n      return false;\r\n    }\r\n\r\n    if (!token) return true;\r\n\r\n    await updateDoc(userRef, { fcmTokens: arrayRemove(token) });\r\n    return true;\r\n  } catch (err) {\r\n    console.error('removeTokenForUser failed:', err);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Listen to foreground messages (when web page is open)\r\n * @param {(payload: Object) => void} callback\r\n * @returns {() => void} unsubscribe function\r\n */\r\nexport function listenForegroundMessages(callback) {\r\n  if (typeof callback !== 'function') {\r\n    throw new Error('listenForegroundMessages: callback function required');\r\n  }\r\n  const messaging = getMessaging();\r\n  const unsub = onMessage(messaging, (payload) => {\r\n    try {\r\n      callback(payload);\r\n    } catch (err) {\r\n      console.error('Error in foreground message callback:', err);\r\n    }\r\n  });\r\n\r\n  return typeof unsub === 'function' ? unsub : () => {};\r\n}\r\n\r\nexport default {\r\n  initMessaging,\r\n  setupAutoRegistration,\r\n  registerTokenForUser,\r\n  removeTokenForUser,\r\n  listenForegroundMessages,\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}