{"ast":null,"code":"/**\r\n * src/firebaseMessaging.js\r\n *\r\n * Uses the default firebase app exported from ./firebase if caller doesn't pass an app.\r\n * Exports:\r\n *  - initMessaging(appOrNull, swPath)\r\n *  - setupAutoRegistration({ app, uid, swPath })\r\n *  - registerTokenForUser(token, uid, app)\r\n *  - removeTokenForUser(uid, app)\r\n *  - listenForegroundMessages(callback, app)\r\n */\n\nimport firebaseAppDefault from './firebase'; // your local firebase initializer (default export)\nimport { getMessaging, getToken, onMessage } from 'firebase/messaging';\nimport { getFirestore, doc, updateDoc, arrayUnion, arrayRemove, getDoc, setDoc } from 'firebase/firestore';\n\n/* Helper: resolve a firebase app instance. Use provided app, otherwise fall back to default export. */\nfunction resolveApp(maybeApp) {\n  if (maybeApp) return maybeApp;\n  if (firebaseAppDefault) return firebaseAppDefault;\n  throw new Error('Firebase app instance required. Initialize firebase app and pass it or ensure default export exists in ./firebase.');\n}\n\n/**\r\n * Initialize messaging and register service worker.\r\n * @param {FirebaseApp|null} appOrNull\r\n * @param {string} swPath\r\n * @returns {Promise<{messaging: Messaging, serviceWorkerRegistration: ServiceWorkerRegistration|null}>}\r\n */\nexport async function initMessaging(appOrNull = null, swPath = '/firebase-messaging-sw.js') {\n  const app = resolveApp(appOrNull);\n  let registration = null;\n  if ('serviceWorker' in navigator) {\n    try {\n      registration = await navigator.serviceWorker.register(swPath);\n    } catch (err) {\n      console.warn('Service worker registration failed:', err);\n    }\n  } else {\n    console.warn('Service workers are not supported in this browser.');\n  }\n  const messaging = getMessaging(app);\n  return {\n    messaging,\n    serviceWorkerRegistration: registration\n  };\n}\n\n/**\r\n * Request permission, get token and register it for the uid in Firestore.\r\n * @param {{app?: FirebaseApp, uid: string, swPath?: string}} param0\r\n */\nexport async function setupAutoRegistration({\n  app: maybeApp = null,\n  uid,\n  swPath\n} = {}) {\n  const app = resolveApp(maybeApp);\n  if (!uid) throw new Error('setupAutoRegistration: uid is required');\n  const permission = await Notification.requestPermission();\n  if (permission !== 'granted') {\n    console.warn('Notification permission not granted:', permission);\n    return null;\n  }\n  const {\n    messaging,\n    serviceWorkerRegistration\n  } = await initMessaging(app, swPath);\n  const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\n  try {\n    let currentToken;\n    if (serviceWorkerRegistration) {\n      if (vapidKey) {\n        currentToken = await getToken(messaging, {\n          vapidKey,\n          serviceWorkerRegistration\n        });\n      } else {\n        currentToken = await getToken(messaging, {\n          serviceWorkerRegistration\n        });\n      }\n    } else {\n      if (vapidKey) {\n        currentToken = await getToken(messaging, {\n          vapidKey\n        });\n      } else {\n        currentToken = await getToken(messaging);\n      }\n    }\n    if (currentToken) {\n      await registerTokenForUser(currentToken, uid, app);\n      return currentToken;\n    } else {\n      console.warn('No registration token available.');\n      return null;\n    }\n  } catch (err) {\n    console.error('An error occurred while retrieving token. ', err);\n    throw err;\n  }\n}\n\n/**\r\n * Store token into users/{uid}.fcmTokens array in Firestore.\r\n */\nexport async function registerTokenForUser(token, uid, app = null) {\n  if (!token) throw new Error('registerTokenForUser: token required');\n  if (!uid) throw new Error('registerTokenForUser: uid required');\n  const appToUse = resolveApp(app);\n  const db = getFirestore(appToUse);\n  const userRef = doc(db, 'users', uid);\n  try {\n    const snapshot = await getDoc(userRef);\n    if (!snapshot.exists()) {\n      await setDoc(userRef, {\n        fcmTokens: [token]\n      }, {\n        merge: true\n      });\n    } else {\n      await updateDoc(userRef, {\n        fcmTokens: arrayUnion(token)\n      });\n    }\n  } catch (err) {\n    console.error('registerTokenForUser failed:', err);\n    throw err;\n  }\n}\n\n/**\r\n * Remove current device token from users/{uid}.fcmTokens array.\r\n */\nexport async function removeTokenForUser(uid, app = null) {\n  if (!uid) throw new Error('removeTokenForUser: uid required');\n  const appToUse = resolveApp(app);\n  const db = getFirestore(appToUse);\n  const userRef = doc(db, 'users', uid);\n  try {\n    const messaging = getMessaging(appToUse);\n    const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\n    let token = null;\n    try {\n      if (vapidKey) token = await getToken(messaging, {\n        vapidKey\n      });else token = await getToken(messaging);\n    } catch (tErr) {\n      console.warn('Could not fetch current token (getToken):', tErr);\n      return false;\n    }\n    if (!token) return true;\n    await updateDoc(userRef, {\n      fcmTokens: arrayRemove(token)\n    });\n    return true;\n  } catch (err) {\n    console.error('removeTokenForUser failed:', err);\n    return false;\n  }\n}\n\n/**\r\n * Listen to foreground messages. Optionally pass an app to ensure correct messaging instance.\r\n * @param {(payload:Object)=>void} callback\r\n * @param {FirebaseApp|null} app\r\n */\nexport function listenForegroundMessages(callback, app = null) {\n  if (typeof callback !== 'function') throw new Error('listenForegroundMessages: callback function required');\n  const appToUse = resolveApp(app);\n  const messaging = getMessaging(appToUse);\n  const unsub = onMessage(messaging, payload => {\n    try {\n      callback(payload);\n    } catch (err) {\n      console.error('Error in foreground message callback:', err);\n    }\n  });\n  return typeof unsub === 'function' ? unsub : () => {};\n}\nexport default {\n  initMessaging,\n  setupAutoRegistration,\n  registerTokenForUser,\n  removeTokenForUser,\n  listenForegroundMessages\n};","map":{"version":3,"names":["firebaseAppDefault","getMessaging","getToken","onMessage","getFirestore","doc","updateDoc","arrayUnion","arrayRemove","getDoc","setDoc","resolveApp","maybeApp","Error","initMessaging","appOrNull","swPath","app","registration","navigator","serviceWorker","register","err","console","warn","messaging","serviceWorkerRegistration","setupAutoRegistration","uid","permission","Notification","requestPermission","vapidKey","process","env","REACT_APP_FIREBASE_VAPID_KEY","REACT_APP_VAPID_KEY","currentToken","registerTokenForUser","error","token","appToUse","db","userRef","snapshot","exists","fcmTokens","merge","removeTokenForUser","tErr","listenForegroundMessages","callback","unsub","payload"],"sources":["C:/Users/rajya/Desktop/Coding/WebDev/Programs/mini_project_LifeLink/blood-donor-finder/frontend/src/firebaseMessaging.js"],"sourcesContent":["/**\r\n * src/firebaseMessaging.js\r\n *\r\n * Uses the default firebase app exported from ./firebase if caller doesn't pass an app.\r\n * Exports:\r\n *  - initMessaging(appOrNull, swPath)\r\n *  - setupAutoRegistration({ app, uid, swPath })\r\n *  - registerTokenForUser(token, uid, app)\r\n *  - removeTokenForUser(uid, app)\r\n *  - listenForegroundMessages(callback, app)\r\n */\r\n\r\nimport firebaseAppDefault from './firebase'; // your local firebase initializer (default export)\r\nimport { getMessaging, getToken, onMessage } from 'firebase/messaging';\r\nimport {\r\n  getFirestore,\r\n  doc,\r\n  updateDoc,\r\n  arrayUnion,\r\n  arrayRemove,\r\n  getDoc,\r\n  setDoc,\r\n} from 'firebase/firestore';\r\n\r\n/* Helper: resolve a firebase app instance. Use provided app, otherwise fall back to default export. */\r\nfunction resolveApp(maybeApp) {\r\n  if (maybeApp) return maybeApp;\r\n  if (firebaseAppDefault) return firebaseAppDefault;\r\n  throw new Error('Firebase app instance required. Initialize firebase app and pass it or ensure default export exists in ./firebase.');\r\n}\r\n\r\n/**\r\n * Initialize messaging and register service worker.\r\n * @param {FirebaseApp|null} appOrNull\r\n * @param {string} swPath\r\n * @returns {Promise<{messaging: Messaging, serviceWorkerRegistration: ServiceWorkerRegistration|null}>}\r\n */\r\nexport async function initMessaging(appOrNull = null, swPath = '/firebase-messaging-sw.js') {\r\n  const app = resolveApp(appOrNull);\r\n\r\n  let registration = null;\r\n  if ('serviceWorker' in navigator) {\r\n    try {\r\n      registration = await navigator.serviceWorker.register(swPath);\r\n    } catch (err) {\r\n      console.warn('Service worker registration failed:', err);\r\n    }\r\n  } else {\r\n    console.warn('Service workers are not supported in this browser.');\r\n  }\r\n\r\n  const messaging = getMessaging(app);\r\n  return { messaging, serviceWorkerRegistration: registration };\r\n}\r\n\r\n/**\r\n * Request permission, get token and register it for the uid in Firestore.\r\n * @param {{app?: FirebaseApp, uid: string, swPath?: string}} param0\r\n */\r\nexport async function setupAutoRegistration({ app: maybeApp = null, uid, swPath } = {}) {\r\n  const app = resolveApp(maybeApp);\r\n  if (!uid) throw new Error('setupAutoRegistration: uid is required');\r\n\r\n  const permission = await Notification.requestPermission();\r\n  if (permission !== 'granted') {\r\n    console.warn('Notification permission not granted:', permission);\r\n    return null;\r\n  }\r\n\r\n  const { messaging, serviceWorkerRegistration } = await initMessaging(app, swPath);\r\n  const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\r\n\r\n  try {\r\n    let currentToken;\r\n    if (serviceWorkerRegistration) {\r\n      if (vapidKey) {\r\n        currentToken = await getToken(messaging, { vapidKey, serviceWorkerRegistration });\r\n      } else {\r\n        currentToken = await getToken(messaging, { serviceWorkerRegistration });\r\n      }\r\n    } else {\r\n      if (vapidKey) {\r\n        currentToken = await getToken(messaging, { vapidKey });\r\n      } else {\r\n        currentToken = await getToken(messaging);\r\n      }\r\n    }\r\n\r\n    if (currentToken) {\r\n      await registerTokenForUser(currentToken, uid, app);\r\n      return currentToken;\r\n    } else {\r\n      console.warn('No registration token available.');\r\n      return null;\r\n    }\r\n  } catch (err) {\r\n    console.error('An error occurred while retrieving token. ', err);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * Store token into users/{uid}.fcmTokens array in Firestore.\r\n */\r\nexport async function registerTokenForUser(token, uid, app = null) {\r\n  if (!token) throw new Error('registerTokenForUser: token required');\r\n  if (!uid) throw new Error('registerTokenForUser: uid required');\r\n\r\n  const appToUse = resolveApp(app);\r\n  const db = getFirestore(appToUse);\r\n  const userRef = doc(db, 'users', uid);\r\n\r\n  try {\r\n    const snapshot = await getDoc(userRef);\r\n    if (!snapshot.exists()) {\r\n      await setDoc(userRef, { fcmTokens: [token] }, { merge: true });\r\n    } else {\r\n      await updateDoc(userRef, { fcmTokens: arrayUnion(token) });\r\n    }\r\n  } catch (err) {\r\n    console.error('registerTokenForUser failed:', err);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * Remove current device token from users/{uid}.fcmTokens array.\r\n */\r\nexport async function removeTokenForUser(uid, app = null) {\r\n  if (!uid) throw new Error('removeTokenForUser: uid required');\r\n\r\n  const appToUse = resolveApp(app);\r\n  const db = getFirestore(appToUse);\r\n  const userRef = doc(db, 'users', uid);\r\n\r\n  try {\r\n    const messaging = getMessaging(appToUse);\r\n    const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || process.env.REACT_APP_VAPID_KEY || null;\r\n\r\n    let token = null;\r\n    try {\r\n      if (vapidKey) token = await getToken(messaging, { vapidKey });\r\n      else token = await getToken(messaging);\r\n    } catch (tErr) {\r\n      console.warn('Could not fetch current token (getToken):', tErr);\r\n      return false;\r\n    }\r\n\r\n    if (!token) return true;\r\n\r\n    await updateDoc(userRef, { fcmTokens: arrayRemove(token) });\r\n    return true;\r\n  } catch (err) {\r\n    console.error('removeTokenForUser failed:', err);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Listen to foreground messages. Optionally pass an app to ensure correct messaging instance.\r\n * @param {(payload:Object)=>void} callback\r\n * @param {FirebaseApp|null} app\r\n */\r\nexport function listenForegroundMessages(callback, app = null) {\r\n  if (typeof callback !== 'function') throw new Error('listenForegroundMessages: callback function required');\r\n  const appToUse = resolveApp(app);\r\n  const messaging = getMessaging(appToUse);\r\n  const unsub = onMessage(messaging, (payload) => {\r\n    try {\r\n      callback(payload);\r\n    } catch (err) {\r\n      console.error('Error in foreground message callback:', err);\r\n    }\r\n  });\r\n  return typeof unsub === 'function' ? unsub : () => {};\r\n}\r\n\r\nexport default {\r\n  initMessaging,\r\n  setupAutoRegistration,\r\n  registerTokenForUser,\r\n  removeTokenForUser,\r\n  listenForegroundMessages,\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}