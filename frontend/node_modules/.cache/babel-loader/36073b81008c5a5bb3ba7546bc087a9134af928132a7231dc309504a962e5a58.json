{"ast":null,"code":"// src/firebaseMessaging.js\nimport { getMessaging, getToken, onMessage, deleteToken } from \"firebase/messaging\";\nimport { doc, setDoc, deleteDoc } from \"firebase/firestore\";\nimport { auth, db, messaging } from \"./components/firebase\"; // your existing modular firebase.js\nimport { onAuthStateChanged } from \"firebase/auth\";\nconst VAPID_KEY = \"BIO2Mc6NhNj7m9xAN8OctwR5lWFytEx-1cnnjpqTTWHeJBPbwg0Qo4LbbVrEmmkfjju5835EtZD03Mgmo7K1dmc\"; // paste the VAPID public key\n\nlet messagingInstance = null;\nexport function initMessaging() {\n  if (typeof window === \"undefined\" || !(\"serviceWorker\" in navigator)) return;\n  try {\n    messagingInstance = getMessaging();\n  } catch (e) {\n    console.warn(\"FCM init failed\", e);\n  }\n}\n\n// Call this after user logs in (or once app starts if user already logged in)\nexport async function registerTokenForUser(uid) {\n  if (!uid) return null;\n  if (!messagingInstance) initMessaging();\n  if (!messagingInstance) return null;\n  try {\n    // Ensure the service worker is registered\n    const swReg = await navigator.serviceWorker.register(\"/firebase-messaging-sw.js\");\n    // Ask permission\n    const permission = await Notification.requestPermission();\n    if (permission !== \"granted\") {\n      console.warn(\"Notification permission not granted\");\n      return null;\n    }\n\n    // Get FCM token\n    const token = await getToken(messagingInstance, {\n      vapidKey: VAPID_KEY,\n      serviceWorkerRegistration: swReg\n    });\n    if (!token) {\n      console.warn(\"No FCM token returned\");\n      return null;\n    }\n\n    // Save token to Firestore: either UserTokens/<uid> or update Donors/<uid>.fcmToken\n    await setDoc(doc(db, \"UserTokens\", uid), {\n      token,\n      updatedAt: new Date().toISOString()\n    });\n\n    // Optional: also update Donors collection if that user is a donor record\n    await setDoc(doc(db, \"Donors\", uid), {\n      fcmToken: token\n    }, {\n      merge: true\n    });\n    console.log(\"FCM token saved for user\", uid);\n    return token;\n  } catch (err) {\n    console.error(\"registerTokenForUser error\", err);\n    return null;\n  }\n}\nexport async function removeTokenForUser(uid) {\n  try {\n    await deleteDoc(doc(db, \"UserTokens\", uid));\n  } catch (_) {}\n  try {\n    await deleteToken(messaging);\n  } catch (_) {}\n}\n\n// Optional: in-app foreground callback\nexport function subscribeOnMessage(cb) {\n  if (!messagingInstance) initMessaging();\n  if (!messagingInstance) return;\n  onMessage(messagingInstance, payload => {\n    if (typeof cb === \"function\") cb(payload);\n  });\n}\n\n// Auto-register token when user signs in; remove on sign out.\n// Add this call once in your App entry (see next step)\nexport function setupAutoRegistration() {\n  onAuthStateChanged(auth, async user => {\n    if (user) {\n      // register token for signed-in user\n      await registerTokenForUser(user.uid);\n    } else {\n      // logged out: delete token from DB\n      // If you stored uid earlier, remove it. Here we can't access previous uid; ensure you remove on logout flow.\n    }\n  });\n}","map":{"version":3,"names":["getMessaging","getToken","onMessage","deleteToken","doc","setDoc","deleteDoc","auth","db","messaging","onAuthStateChanged","VAPID_KEY","messagingInstance","initMessaging","window","navigator","e","console","warn","registerTokenForUser","uid","swReg","serviceWorker","register","permission","Notification","requestPermission","token","vapidKey","serviceWorkerRegistration","updatedAt","Date","toISOString","fcmToken","merge","log","err","error","removeTokenForUser","_","subscribeOnMessage","cb","payload","setupAutoRegistration","user"],"sources":["C:/Users/rajya/Desktop/Coding/WebDev/Programs/mini_project_LifeLink/blood-donor-finder/frontend/src/firebaseMessaging.js"],"sourcesContent":["// src/firebaseMessaging.js\r\nimport { getMessaging, getToken, onMessage, deleteToken } from \"firebase/messaging\";\r\nimport { doc, setDoc, deleteDoc } from \"firebase/firestore\";\r\nimport { auth, db, messaging } from \"./components/firebase\"; // your existing modular firebase.js\r\nimport { onAuthStateChanged } from \"firebase/auth\";\r\n\r\nconst VAPID_KEY = \"BIO2Mc6NhNj7m9xAN8OctwR5lWFytEx-1cnnjpqTTWHeJBPbwg0Qo4LbbVrEmmkfjju5835EtZD03Mgmo7K1dmc\"; // paste the VAPID public key\r\n\r\nlet messagingInstance = null;\r\n\r\nexport function initMessaging() {\r\n  if (typeof window === \"undefined\" || !(\"serviceWorker\" in navigator)) return;\r\n  try {\r\n    messagingInstance = getMessaging();\r\n  } catch (e) {\r\n    console.warn(\"FCM init failed\", e);\r\n  }\r\n}\r\n\r\n// Call this after user logs in (or once app starts if user already logged in)\r\nexport async function registerTokenForUser(uid) {\r\n  if (!uid) return null;\r\n  if (!messagingInstance) initMessaging();\r\n  if (!messagingInstance) return null;\r\n\r\n  try {\r\n    // Ensure the service worker is registered\r\n    const swReg = await navigator.serviceWorker.register(\"/firebase-messaging-sw.js\");\r\n    // Ask permission\r\n    const permission = await Notification.requestPermission();\r\n    if (permission !== \"granted\") {\r\n      console.warn(\"Notification permission not granted\");\r\n      return null;\r\n    }\r\n\r\n    // Get FCM token\r\n    const token = await getToken(messagingInstance, { vapidKey: VAPID_KEY, serviceWorkerRegistration: swReg });\r\n    if (!token) {\r\n      console.warn(\"No FCM token returned\");\r\n      return null;\r\n    }\r\n\r\n    // Save token to Firestore: either UserTokens/<uid> or update Donors/<uid>.fcmToken\r\n    await setDoc(doc(db, \"UserTokens\", uid), { token, updatedAt: new Date().toISOString() });\r\n\r\n    // Optional: also update Donors collection if that user is a donor record\r\n    await setDoc(doc(db, \"Donors\", uid), { fcmToken: token }, { merge: true });\r\n\r\n    console.log(\"FCM token saved for user\", uid);\r\n    return token;\r\n  } catch (err) {\r\n    console.error(\"registerTokenForUser error\", err);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function removeTokenForUser(uid) {\r\n  try {\r\n    await deleteDoc(doc(db, \"UserTokens\", uid));\r\n  } catch (_) {}\r\n\r\n  try {\r\n    await deleteToken(messaging);\r\n  } catch (_) {}\r\n}\r\n\r\n// Optional: in-app foreground callback\r\nexport function subscribeOnMessage(cb) {\r\n  if (!messagingInstance) initMessaging();\r\n  if (!messagingInstance) return;\r\n  onMessage(messagingInstance, (payload) => {\r\n    if (typeof cb === \"function\") cb(payload);\r\n  });\r\n}\r\n\r\n// Auto-register token when user signs in; remove on sign out.\r\n// Add this call once in your App entry (see next step)\r\nexport function setupAutoRegistration() {\r\n  onAuthStateChanged(auth, async (user) => {\r\n    if (user) {\r\n      // register token for signed-in user\r\n      await registerTokenForUser(user.uid);\r\n    } else {\r\n      // logged out: delete token from DB\r\n      // If you stored uid earlier, remove it. Here we can't access previous uid; ensure you remove on logout flow.\r\n    }\r\n  });\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}