{"ast":null,"code":"/**\r\n * firebaseMessaging.js\r\n *\r\n * Modular Firebase (v9+/v12) helper for web FCM.\r\n *\r\n * Exports:\r\n *  - initMessaging(app, swPath) -> { messaging, serviceWorkerRegistration }\r\n *  - setupAutoRegistration({ app, uid, swPath }) -> token|null\r\n *  - registerTokenForUser(token, uid, app)\r\n *  - removeTokenForUser(uid, app)\r\n *  - listenForegroundMessages(callback, app)\r\n *\r\n * Requirements:\r\n *  - Add public/firebase-messaging-sw.js to your CRA public/ folder (sample below).\r\n *  - Set REACT_APP_FIREBASE_VAPID_KEY in .env for reliable token registration.\r\n */\n\nimport { getMessaging, getToken, onMessage } from 'firebase/messaging';\nimport { getFirestore, doc, updateDoc, arrayUnion, arrayRemove, getDoc, setDoc } from 'firebase/firestore';\n\n/**\r\n * Initialize messaging and register service worker.\r\n * @param {FirebaseApp} app - firebase app instance\r\n * @param {string} [swPath='/firebase-messaging-sw.js'] - path in public/\r\n * @returns {Promise<{messaging: Messaging, serviceWorkerRegistration: ServiceWorkerRegistration|null}>}\r\n */\nexport async function initMessaging(app, swPath = '/firebase-messaging-sw.js') {\n  if (!app) throw new Error('initMessaging: firebase app instance required');\n  let registration = null;\n  if ('serviceWorker' in navigator) {\n    try {\n      registration = await navigator.serviceWorker.register(swPath);\n    } catch (err) {\n      console.warn('Service worker registration failed (continuing):', err);\n      registration = null;\n    }\n  } else {\n    console.warn('Service workers not supported in this browser.');\n  }\n  const messaging = getMessaging(app);\n  return {\n    messaging,\n    serviceWorkerRegistration: registration\n  };\n}\n\n/**\r\n * Request permission, get token, and register it for the user in Firestore.\r\n * @param {Object} opts\r\n * @param {FirebaseApp} opts.app\r\n * @param {string} opts.uid\r\n * @param {string} [opts.swPath]\r\n * @returns {Promise<string|null>}\r\n */\nexport async function setupAutoRegistration({\n  app,\n  uid,\n  swPath\n}) {\n  if (!app) throw new Error('setupAutoRegistration: firebase app is required');\n  if (!uid) throw new Error('setupAutoRegistration: uid is required');\n  const permission = await Notification.requestPermission();\n  if (permission !== 'granted') {\n    console.warn('Notification permission not granted:', permission);\n    return null;\n  }\n  const {\n    messaging,\n    serviceWorkerRegistration\n  } = await initMessaging(app, swPath);\n  const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || null;\n  try {\n    let currentToken = null;\n    const getTokenOptions = {};\n    if (vapidKey) getTokenOptions.vapidKey = vapidKey;\n    if (serviceWorkerRegistration) getTokenOptions.serviceWorkerRegistration = serviceWorkerRegistration;\n    currentToken = await getToken(messaging, getTokenOptions);\n    if (currentToken) {\n      await registerTokenForUser(currentToken, uid, app);\n      return currentToken;\n    } else {\n      console.warn('FCM: No registration token available.');\n      return null;\n    }\n  } catch (err) {\n    console.error('FCM getToken error:', err);\n    throw err;\n  }\n}\n\n/**\r\n * Store token in Firestore under users/{uid}.fcmTokens (array).\r\n * @param {string} token\r\n * @param {string} uid\r\n * @param {FirebaseApp} [app]\r\n */\nexport async function registerTokenForUser(token, uid, app = null) {\n  if (!token) throw new Error('registerTokenForUser: token required');\n  if (!uid) throw new Error('registerTokenForUser: uid required');\n  const db = getFirestore(app);\n  const userRef = doc(db, 'users', uid);\n  try {\n    const snapshot = await getDoc(userRef);\n    if (!snapshot.exists()) {\n      await setDoc(userRef, {\n        fcmTokens: [token]\n      }, {\n        merge: true\n      });\n    } else {\n      await updateDoc(userRef, {\n        fcmTokens: arrayUnion(token)\n      });\n    }\n  } catch (err) {\n    console.error('registerTokenForUser failed:', err);\n    throw err;\n  }\n}\n\n/**\r\n * Remove this device's token from users/{uid}.fcmTokens.\r\n * @param {string} uid\r\n * @param {FirebaseApp} [app]\r\n * @returns {Promise<boolean>}\r\n */\nexport async function removeTokenForUser(uid, app = null) {\n  if (!uid) throw new Error('removeTokenForUser: uid required');\n  const db = getFirestore(app);\n  const userRef = doc(db, 'users', uid);\n  const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || null;\n  try {\n    // Try to retrieve the current token for this client/device\n    const messaging = getMessaging(app);\n    let token = null;\n    try {\n      const opts = vapidKey ? {\n        vapidKey\n      } : undefined;\n      token = await getToken(messaging, opts);\n    } catch (tErr) {\n      console.warn('Could not fetch current token:', tErr);\n    }\n    if (!token) {\n      // Nothing to remove (or token unavailable on client). Return true to allow logout to continue.\n      return true;\n    }\n    await updateDoc(userRef, {\n      fcmTokens: arrayRemove(token)\n    });\n    return true;\n  } catch (err) {\n    console.error('removeTokenForUser failed:', err);\n    return false;\n  }\n}\n\n/**\r\n * Subscribe to foreground messages.\r\n * @param {function} callback - receives payload\r\n * @param {FirebaseApp} [app]\r\n * @returns {function} unsubscribe\r\n */\nexport function listenForegroundMessages(callback, app = null) {\n  if (typeof callback !== 'function') throw new Error('listenForegroundMessages: callback required');\n  const messaging = getMessaging(app);\n  const unsub = onMessage(messaging, payload => {\n    try {\n      callback(payload);\n    } catch (err) {\n      console.error('Foreground message callback error:', err);\n    }\n  });\n  return typeof unsub === 'function' ? unsub : () => {};\n}\nexport default {\n  initMessaging,\n  setupAutoRegistration,\n  registerTokenForUser,\n  removeTokenForUser,\n  listenForegroundMessages\n};","map":{"version":3,"names":["getMessaging","getToken","onMessage","getFirestore","doc","updateDoc","arrayUnion","arrayRemove","getDoc","setDoc","initMessaging","app","swPath","Error","registration","navigator","serviceWorker","register","err","console","warn","messaging","serviceWorkerRegistration","setupAutoRegistration","uid","permission","Notification","requestPermission","vapidKey","process","env","REACT_APP_FIREBASE_VAPID_KEY","currentToken","getTokenOptions","registerTokenForUser","error","token","db","userRef","snapshot","exists","fcmTokens","merge","removeTokenForUser","opts","undefined","tErr","listenForegroundMessages","callback","unsub","payload"],"sources":["C:/Users/rajya/Desktop/Coding/WebDev/Programs/mini_project_LifeLink/blood-donor-finder/frontend/src/firebaseMessaging.js"],"sourcesContent":["/**\r\n * firebaseMessaging.js\r\n *\r\n * Modular Firebase (v9+/v12) helper for web FCM.\r\n *\r\n * Exports:\r\n *  - initMessaging(app, swPath) -> { messaging, serviceWorkerRegistration }\r\n *  - setupAutoRegistration({ app, uid, swPath }) -> token|null\r\n *  - registerTokenForUser(token, uid, app)\r\n *  - removeTokenForUser(uid, app)\r\n *  - listenForegroundMessages(callback, app)\r\n *\r\n * Requirements:\r\n *  - Add public/firebase-messaging-sw.js to your CRA public/ folder (sample below).\r\n *  - Set REACT_APP_FIREBASE_VAPID_KEY in .env for reliable token registration.\r\n */\r\n\r\nimport { getMessaging, getToken, onMessage } from 'firebase/messaging';\r\nimport {\r\n  getFirestore,\r\n  doc,\r\n  updateDoc,\r\n  arrayUnion,\r\n  arrayRemove,\r\n  getDoc,\r\n  setDoc,\r\n} from 'firebase/firestore';\r\n\r\n/**\r\n * Initialize messaging and register service worker.\r\n * @param {FirebaseApp} app - firebase app instance\r\n * @param {string} [swPath='/firebase-messaging-sw.js'] - path in public/\r\n * @returns {Promise<{messaging: Messaging, serviceWorkerRegistration: ServiceWorkerRegistration|null}>}\r\n */\r\nexport async function initMessaging(app, swPath = '/firebase-messaging-sw.js') {\r\n  if (!app) throw new Error('initMessaging: firebase app instance required');\r\n\r\n  let registration = null;\r\n  if ('serviceWorker' in navigator) {\r\n    try {\r\n      registration = await navigator.serviceWorker.register(swPath);\r\n    } catch (err) {\r\n      console.warn('Service worker registration failed (continuing):', err);\r\n      registration = null;\r\n    }\r\n  } else {\r\n    console.warn('Service workers not supported in this browser.');\r\n  }\r\n\r\n  const messaging = getMessaging(app);\r\n  return { messaging, serviceWorkerRegistration: registration };\r\n}\r\n\r\n/**\r\n * Request permission, get token, and register it for the user in Firestore.\r\n * @param {Object} opts\r\n * @param {FirebaseApp} opts.app\r\n * @param {string} opts.uid\r\n * @param {string} [opts.swPath]\r\n * @returns {Promise<string|null>}\r\n */\r\nexport async function setupAutoRegistration({ app, uid, swPath }) {\r\n  if (!app) throw new Error('setupAutoRegistration: firebase app is required');\r\n  if (!uid) throw new Error('setupAutoRegistration: uid is required');\r\n\r\n  const permission = await Notification.requestPermission();\r\n  if (permission !== 'granted') {\r\n    console.warn('Notification permission not granted:', permission);\r\n    return null;\r\n  }\r\n\r\n  const { messaging, serviceWorkerRegistration } = await initMessaging(app, swPath);\r\n  const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || null;\r\n\r\n  try {\r\n    let currentToken = null;\r\n    const getTokenOptions = {};\r\n    if (vapidKey) getTokenOptions.vapidKey = vapidKey;\r\n    if (serviceWorkerRegistration) getTokenOptions.serviceWorkerRegistration = serviceWorkerRegistration;\r\n\r\n    currentToken = await getToken(messaging, getTokenOptions);\r\n\r\n    if (currentToken) {\r\n      await registerTokenForUser(currentToken, uid, app);\r\n      return currentToken;\r\n    } else {\r\n      console.warn('FCM: No registration token available.');\r\n      return null;\r\n    }\r\n  } catch (err) {\r\n    console.error('FCM getToken error:', err);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * Store token in Firestore under users/{uid}.fcmTokens (array).\r\n * @param {string} token\r\n * @param {string} uid\r\n * @param {FirebaseApp} [app]\r\n */\r\nexport async function registerTokenForUser(token, uid, app = null) {\r\n  if (!token) throw new Error('registerTokenForUser: token required');\r\n  if (!uid) throw new Error('registerTokenForUser: uid required');\r\n\r\n  const db = getFirestore(app);\r\n  const userRef = doc(db, 'users', uid);\r\n\r\n  try {\r\n    const snapshot = await getDoc(userRef);\r\n    if (!snapshot.exists()) {\r\n      await setDoc(userRef, { fcmTokens: [token] }, { merge: true });\r\n    } else {\r\n      await updateDoc(userRef, { fcmTokens: arrayUnion(token) });\r\n    }\r\n  } catch (err) {\r\n    console.error('registerTokenForUser failed:', err);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * Remove this device's token from users/{uid}.fcmTokens.\r\n * @param {string} uid\r\n * @param {FirebaseApp} [app]\r\n * @returns {Promise<boolean>}\r\n */\r\nexport async function removeTokenForUser(uid, app = null) {\r\n  if (!uid) throw new Error('removeTokenForUser: uid required');\r\n\r\n  const db = getFirestore(app);\r\n  const userRef = doc(db, 'users', uid);\r\n  const vapidKey = process.env.REACT_APP_FIREBASE_VAPID_KEY || null;\r\n\r\n  try {\r\n    // Try to retrieve the current token for this client/device\r\n    const messaging = getMessaging(app);\r\n    let token = null;\r\n    try {\r\n      const opts = vapidKey ? { vapidKey } : undefined;\r\n      token = await getToken(messaging, opts);\r\n    } catch (tErr) {\r\n      console.warn('Could not fetch current token:', tErr);\r\n    }\r\n\r\n    if (!token) {\r\n      // Nothing to remove (or token unavailable on client). Return true to allow logout to continue.\r\n      return true;\r\n    }\r\n\r\n    await updateDoc(userRef, { fcmTokens: arrayRemove(token) });\r\n    return true;\r\n  } catch (err) {\r\n    console.error('removeTokenForUser failed:', err);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Subscribe to foreground messages.\r\n * @param {function} callback - receives payload\r\n * @param {FirebaseApp} [app]\r\n * @returns {function} unsubscribe\r\n */\r\nexport function listenForegroundMessages(callback, app = null) {\r\n  if (typeof callback !== 'function') throw new Error('listenForegroundMessages: callback required');\r\n  const messaging = getMessaging(app);\r\n  const unsub = onMessage(messaging, (payload) => {\r\n    try {\r\n      callback(payload);\r\n    } catch (err) {\r\n      console.error('Foreground message callback error:', err);\r\n    }\r\n  });\r\n  return typeof unsub === 'function' ? unsub : () => {};\r\n}\r\n\r\nexport default {\r\n  initMessaging,\r\n  setupAutoRegistration,\r\n  registerTokenForUser,\r\n  removeTokenForUser,\r\n  listenForegroundMessages,\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}